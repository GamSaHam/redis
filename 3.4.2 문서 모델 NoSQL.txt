
문서 모델 NoSQL 저장소는 키-값 모델을 개념적으로 확장한 구조
하나의 키에 하나의 구조화된 문서를 저장하고 조회한다.
BigQuery 항목과 비슷하다.
논리적인 데이터의 저장과 조회 방법이 관계형 데이터베이스와 유사하기 때문에 NoSQL을 처음
도입하는 프로젝트에서 많이 선택한다.

공통 특징
문서 모델 NoSQL은 동작하는 방식은 마치 URL을 이용하여 웹 서버에 저장된 HTML 문서를 조회하는 것과
유사한데, URL이 키에 해당하고 HTML 문서가 저장된 데이터에 해당된다.

문서 모델 NoSQL의 키는 문서에 대한 ID로 표현된다. ID에 대한 인덱스를 사용하여 O(1)
시간 안에 문서를 조회할 수 있다. 저장된 문서의 형태에 따라 키 이외의 2차 인덱스를 지원하기
때문에 값을 비교한 조회가 가능하다.

키-값 및 컬럼 NoSQL에 비하여 상대적으로 많은 종류의 기능을 제공하며, 관계형 데이터베이스와 유사한 검색
조건을 포함한 쿼리를 처리할 수 있다. 
대부분 문서 모델 NoSQL은 B트리 인덱스를 사용하여 2차 인덱스를 생성
B트리는 크기가 커지면 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다.

이런 이유로 B트리를 사용하는 문서 모델 NoSQL은 읽기와 쓰기의 비율이 7:3 이상일 때 가장 좋은 
성능을 보인다. 문서 모델 NoSQL은 MongoDB, 카우치베이스, 테라스토어, 레이븐DB등 이다.

MongoDB - 자동 샤딩을 지원하는 NoSQL
카우치베이스 - B트리의 단점을 보완한 수정된 B트리 인덱스를 사용, 자체 클러스트 모니터링 기능이 뛰어난
문서 모델 NoSQL
테라스토어 - Quartz Scheduler를 만든 테라코타 시 에서 만들었다. 일관성을 희생시키지 않으면서
동적 확장과 자동샤딩을 지원하는 문서 모델 NoSQL이다.

데이터 저장방법
문서 모델 NoSQL은 구조화된 문서 데이터를 저장하며, 문서 안에 문서를 포함하는 내포 관계 정의하거나 문서의
참조를 지정할 수 있다. 
관계형 데이터 베이스에서는 위와 같이 데이터를 저장하기 위해서 반드시 skills 컬럼을 정의하고 null 값을 넣어야
하지만, 문서 모델 NoSQL은 항상 고정된 필드를 가진 구조의 문서를 저장할 필요가 없다.

데이터 변환
관계형 데이터베이스에 저장된 데이터를 문서 모델 NoSQL에서 어떻게 다루는지 알아보자

키 하나의 여러 정보를 포함하는 문서 구조를 저장했다. user:1:orderlist키는 사용자1의 주문 목록을 저장하고 있으며,
문서 내부에 개별 주문정보가 포함되어 있다.

1. 주문 목록이 저장된 user:1:orderlist 키의 order 필드를 조회한다.
2. 주문 4를 가진 주문 정보를 생성한다. 다음으로 1과 같은 이전 주문 목록이 존재하면 주문 정보를 추가하고, 존재하지
않으면 주문 정보를 입력한다.

단 1회 조회 연산과 1회의 입력 연산으로 모든 처리가 완료된다. 저장된 값의 뒤에 새로운 값을 추가하는 append 명령을 지원하는
NoSQL이라면 단 1회의 연산만으로 처리를 완료할 수 있다. 

이번에는 사용자1이 구매한 상품의 목록을 조회해보자. user:1:orderlist 키에 저장된 문서의 order 필드를 조회하면 모든 주문 내용을
조회할 수 있다. 단 1회의 조회 연산으로 처리가 완료됐다.
키-값 모델 NoSQL의 비하여 저장구조는 복잡하지만 데이터 처리 연산은 상대적으로 간단하다.

적절한 사용처
문서 모델 NoSQL은 B트리의 특성으로 인하여 한 번 작성되면 자주 변하지 않는 정보를 저장하고 조회하는 데 적합하다.
예를 들어 중앙 집중식 로그 저장, 타임 라인 저장, 통계 정보 저장 등이 이에 해당된다. 
단, 조회 시 특정 수량을 기준으로 잘라서 조회하는 기능 등에는 알맞지 않다.

서문 모델 NoSQL이 지원하는 2차 인덱스와 상세한 쿼리 기능으로 인하여 문서 모델 NoSQL로 관계형 데이터베이스를 대체하려는 시도들이 있었는데,
이런 시도는 대체로 실패로 돌아갔다.

문서 모델 NoSQL이 복잡한 조건의 쿼리를 지원하기는 하지만, 관계형 데이터베이스에서 지원하는 기능에는 아직 미치지 못한다.

2차 인덱스는 조회 기능의 편의성을 제공하기도 하지만, 쓰기 성능을 저하시키는 양날의 검과 같은 기능이다.
지속적인 데이터의 입력 상황에서는 인덱스가 설정되지 않은 컬렉션에 대한 쓰기 성능과 설정된 컬렉션에 대한 쓰기 성능이 최대 100배 정도 차이 난다.
