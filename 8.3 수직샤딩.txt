8.2.1 수직 샤딩
수직 샤딩이란 데이터의 성격을 기준으로 논리적 분할을 적용
관계형 데이터 베이스로 예를 들면 사용자 정보는 샤드1, 친구 정보는 샤드2에 저장하도록 하여 데이터를 분산 시킨다.
수직 샤딩은 데이터의 위치를 서비스 레벨에서 지정하기 때문에 몇 가지 이슈가 발생할 수 있다.
먼저 웹 서비스에 수직 샤딩을 적용한 구조다

레디스 클러스터
> 샤드1(사용자정보), 샤드2(친구정보)  - 데이터 계층 

응용프로그램
> 로그인 서비스, 친구조회 서비스

샤드1(사용자정보) -> 로그인서비스, 친구조회 서비스
샤드2(친구정보) -> 친구조회 서비스

[그림 8-8]
1. 수직 샤딩에 의해 분리 저장된 엔터티에 대한 처리 요청이 증가하는 상황을 생각할 수 있다.
예를 들어 갑자기 서비스가 활성화되어 친구 추가 서비스의 호출이 많아지게 되는 상황을 가정해 보자.
하나의 노드가 친구와 관련된 서비스를 제공하므로 처리 성능 확장을 위해서 서비스의 수정과 같은 복잡한 처리 과정을 거쳐야 한다.
또한 데이터를 다른 하드웨어에 설치된 노드로 이동해야 하는데, 이때 필연적으로 서비스 중단이 뒤따른다.

2. 수직 샤딩은 데이터의 저장과 조회가 전적으로 애플리케이션 레벨에서 결정된다. 이와 같은 수직 샤딩은 주로 관계형 데이터 베이스의
샤딩에서 종종 사용된다.

8.2.2 범위 지정 샤딩
범위 지정 샤딩은 입력되는 특정 키에 대하여 범위를 지정하여 저장될 노드를 결정하는 것
사용자 번호를 예로 들수있다. 사용자 1부터 10,000번까지는 샤드 1에 저장하고 10,001 부터 20,000까지는 샤드 2에 저장하여 
데이터 분산 저장하게 된다. 결국 범위 지정 샤딩도 수직 샤딩과 마찬가지로 애플리케이션 레벨에서 데이터의 저장 위치가 결정되며
발생 가능한 문제점 또한 수직 샤딩과 유사하다.

8.2.3 해시 기반 샤딩
레디스는 모든 데이터가 키에 의해 저장되고 조회된다. 그러므로 키의 해시값을 구하여 해시값에 대한 특정 연산을 통해서 키가
저장될 위치를 구하는 방법을 사용한다. 

4개의 샤드로 구성된 클러스터에 user:234를 저장한다고 가정하자.

샤드 번호 = md5('user:234') % 4

위에서 사용된 해시 함수인 md5는 crc32 또는 sha1* 등의 해시 함수로 교체할 수 있다.

키의 해시처리와 해시값에 대한 연산 로직은 클라이언트 라이브러리에 포함되므로 라이브러리를 사용하는 시점에서는

데이터 저장 위치를 신경 쓰지 않아도 된다.

해시 기반 샤딩 이외의 방법은 모두 애플리케이션에서 처리해야 하므로 이 책에서 다루지 않는다. 이제부터는 제디스를 사용한

해시 기반 샤딩의 구현 방법을 알아보자. 

클라이언트 측 샤딩은 라이브러리 지원이 필수다. 즉, 사용하는 라이브러리가 클라이언트 측 샤딩을 지원해야 한다.

만약 사용하는 레디스 클라이언트 라이브러리가 클라이언트 측 샤딩을 지원하지 않는다면 직접 구현해야 한다.

제디스는 샤딩을 위한 해시 함수로 MD5와 MurmurHash** 알고리즘을 지원한다.

먼저 샤딩을 수행하기 위한 두 개의 레디스 인스턴스를 생성하자. 샤딩을 위한 인스턴스는 

복제 테스트를 위한 레디스 인스턴스와 포트가 겹치지 않도록 6380, 6381 포트를 사용하며 각 인스턴스는 서로 연관이 없는 단일 마스

터로 동작한다.

6380.conf
#redis configuration
port 6380
dbfilename 6380.rdb

6381.conf
#redis configuration
port 6381
dbfilename 6381.rdb

편의상 6380 실행되는 샤드1 로 지정한다.








