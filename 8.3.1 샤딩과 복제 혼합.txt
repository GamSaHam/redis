레디스 클러스터
>
샤드1 > 마스터노드, 슬레이브 노드
샤드2 > 마스터 노드, 슬레이브 노드
[그림 8-9]

10개 의 데이터가 두개의 샤드에 나누어 저장된 상태를 보여준다. 이와 같은 구성은 쓰기와 읽기를 동시에
확장하는 구조다. 

[예제 8-20] 은 해시 기반 샤딩을 위한 핼퍼 클래스 이기 때문이다.

[그림 8-9]와 같은 구성에서 레디스 클러스터 헬퍼 클래스를 그대로 사용하면 슬레이브 노드에 대한 쓰기 연산이

발생하여 데이터의 정합성을 보장 받을 수 없다. 

정합성이란 데이터가 일관된 상태를 말한다. 정합성을 지키는 방법은 제약조건을 추가하거나 하는 방식으로

설정할 수 있다.

이처럼 클러스터를 지원하는 클라이언트는 마스터와 슬레이브를 구분하는 정보를 클라이언트 레벨에서 인식할 수 있어야 하며,
쓰기 연산과 읽기 연산을 마스터와 슬레이브로 나누어 전송하는 로직이 포함된 클래스를 구현해야 한다.

마치며
즉 클러스터에 변경이 발생하면 클라이언트 라이브러리의 변경이 뒤따른다. 이와 같은 문제점을 해결하기 위하여 클러스터의
정보를 원격 서버에 저장하고 클라이언트에서 원격 서버로부터 클러스터 정보를 업데이트하도록 구성하기도 한다.

레디스의 샤딩 구성에서 가장 중요한 부분은 해시 함수의 선택이다. 만약 아무런 비교 없이 샤딩의 해시 함수를 선택하여
운영 시스템에 적용한다면, 나중에 해시 함수를 바꾸기 위하여 클러스터의 전체 데이터를 마이그레이션해야 하는 상황에 
맞딱뜨리게 될 것이다. 데이터의 저장 위치는 해시 함수의 결과에 따라서 정해지기 때문에 운영 중간에 해시 함수의 변경으로
전체 데이터의 위치를 다시 정해야 하는 상황이 발생할 수 있다는 것이다.







